# MongoDB Encryption at Rest - Comprehensive Learning Notes

## What is Encryption at Rest?

**Encryption at Rest** refers to the protection of data when it's stored persistently on disk or in a database. Unlike encryption in transit (which protects data while moving between systems), encryption at rest ensures that stored data remains secure even if physical storage is compromised.

In MongoDB context, this means encrypting:
- Database files stored on the server
- Individual field values within documents
- Backup files and logs

## Two Levels of Encryption at Rest

### 1. Storage-Level Encryption (File System Encryption)

**What it is:** Encrypts the entire database files at the storage level

**Features:**
- Built into MongoDB Enterprise Server
- Transparent to applications - no code changes required
- Encrypts all data files, journal files, and log files
- Uses AES-256 encryption in CBC mode
- Key management through KMIP or local key files

**Benefits:**
- Protects against physical theft of storage devices
- Compliance with regulations (GDPR, HIPAA, etc.)
- No performance impact on queries (encryption/decryption handled at storage layer)

**Limitations:**
- Enterprise feature only (not available in Community Edition)
- Doesn't protect against database-level access breaches
- All data encrypted with same key

### 2. Field-Level Encryption (Application-Level)

**What it is:** Encrypting specific sensitive fields within documents before storing

**Approaches:**
- **Manual Hashing/Encryption:** Developer implements encryption in application code
- **Client-Side Field Level Encryption (CSFLE):** MongoDB Enterprise feature for automatic encryption
- **Queryable Encryption:** New MongoDB feature allowing queries on encrypted data

**Common Use Cases:**
- Password hashing (using bcrypt, Argon2, etc.)
- PII data (Social Security Numbers, Credit Card Numbers)
- Sensitive business data (salaries, medical records)

## Implementation Examples

### REST API with Password Hashing Example

```javascript
// User Registration API with Password Hashing
const express = require('express');
const bcrypt = require('bcrypt');
const { MongoClient } = require('mongodb');

const app = express();
app.use(express.json());

// MongoDB connection
const client = new MongoClient('mongodb://localhost:27017');
const db = client.db('userapp');
const users = db.collection('users');

// User Registration Endpoint
app.post('/api/users/register', async (req, res) => {
  try {
    const { username, email, password } = req.body;
    
    // Hash password before storing
    const saltRounds = 12;
    const hashedPassword = await bcrypt.hash(password, saltRounds);
    
    const user = {
      username,
      email,
      password: hashedPassword, // Store hashed password, never plain text
      createdAt: new Date(),
      lastLogin: null
    };
    
    const result = await users.insertOne(user);
    
    // Return user without password
    const { password: _, ...userResponse } = user;
    res.status(201).json({
      success: true,
      user: userResponse,
      id: result.insertedId
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// User Login Endpoint
app.post('/api/users/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find user by email
    const user = await users.findOne({ email });
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Compare provided password with hashed password
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Update last login
    await users.updateOne(
      { _id: user._id },
      { $set: { lastLogin: new Date() } }
    );
    
    const { password: _, ...userResponse } = user;
    res.json({
      success: true,
      user: userResponse,
      message: 'Login successful'
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### Advanced Field Encryption Example

```javascript
// Encrypting sensitive user data
const crypto = require('crypto');

class FieldEncryption {
  constructor(secretKey) {
    this.algorithm = 'aes-256-gcm';
    this.secretKey = crypto.scryptSync(secretKey, 'salt', 32);
  }
  
  encrypt(text) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.secretKey, iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;
  }
  
  decrypt(encryptedData) {
    const parts = encryptedData.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const authTag = Buffer.from(parts[1], 'hex');
    const encrypted = parts[2];
    
    const decipher = crypto.createDecipher(this.algorithm, this.secretKey, iv);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  }
}

// Usage in API
const fieldEncryption = new FieldEncryption(process.env.ENCRYPTION_KEY);

app.post('/api/users/profile', async (req, res) => {
  try {
    const { userId, ssn, creditCard, address } = req.body;
    
    const sensitiveData = {
      userId,
      ssn: fieldEncryption.encrypt(ssn),           // Encrypt SSN
      creditCard: fieldEncryption.encrypt(creditCard), // Encrypt Credit Card
      address: fieldEncryption.encrypt(address),       // Encrypt Address
      createdAt: new Date()
    };
    
    const result = await db.collection('profiles').insertOne(sensitiveData);
    res.status(201).json({ success: true, id: result.insertedId });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/users/profile/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const profile = await db.collection('profiles').findOne({ userId });
    
    if (!profile) {
      return res.status(404).json({ error: 'Profile not found' });
    }
    
    // Decrypt sensitive fields before sending
    const decryptedProfile = {
      ...profile,
      ssn: fieldEncryption.decrypt(profile.ssn),
      creditCard: fieldEncryption.decrypt(profile.creditCard),
      address: fieldEncryption.decrypt(profile.address)
    };
    
    res.json(decryptedProfile);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

## MongoDB Database Schema Examples

### User Collection with Hashed Passwords
```javascript
// users collection
{
  "_id": ObjectId("..."),
  "username": "john_doe",
  "email": "john@example.com",
  "password": "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj7.LzG8S2cW", // bcrypt hash
  "profile": {
    "firstName": "John",
    "lastName": "Doe"
  },
  "createdAt": ISODate("2024-01-15T10:30:00Z"),
  "lastLogin": ISODate("2024-01-20T15:45:00Z"),
  "role": "user",
  "isActive": true
}
```

### Profile Collection with Encrypted Fields
```javascript
// profiles collection
{
  "_id": ObjectId("..."),
  "userId": "user123",
  "personalInfo": {
    "ssn": "a1b2c3d4:e5f6g7h8:9i0j1k2l3m4n5o6p", // encrypted
    "phoneNumber": "+1-555-0123", // plain text (less sensitive)
    "emergencyContact": "Jane Doe"
  },
  "financialInfo": {
    "creditCard": "x1y2z3a4:b5c6d7e8:f9g0h1i2j3k4l5m6", // encrypted
    "bankAccount": "n7o8p9q0:r1s2t3u4:v5w6x7y8z9a0b1c2" // encrypted
  },
  "address": {
    "street": "d3e4f5g6:h7i8j9k0:l1m2n3o4p5q6r7s8", // encrypted
    "city": "New York", // plain text
    "country": "USA"
  },
  "createdAt": ISODate("2024-01-15T10:35:00Z")
}
```

## Security Best Practices

### 1. Password Security
- **Never store plain text passwords**
- Use strong hashing algorithms (bcrypt, Argon2, scrypt)
- Use appropriate salt rounds (12+ for bcrypt)
- Implement password complexity requirements
- Consider password history to prevent reuse

### 2. Encryption Key Management
- Store encryption keys separately from data
- Use environment variables for keys, never hardcode
- Implement key rotation policies
- Use Key Management Services (AWS KMS, Azure Key Vault)
- Consider using different keys for different data types

### 3. Access Control
- Implement proper authentication and authorization
- Use MongoDB role-based access control (RBAC)
- Audit database access regularly
- Implement connection encryption (TLS/SSL)
- Use IP whitelisting when possible

### 4. Compliance Considerations
- **GDPR:** Right to be forgotten, data portability
- **HIPAA:** PHI encryption requirements
- **PCI DSS:** Credit card data protection
- **SOX:** Financial data integrity

## MongoDB Enterprise Encryption at Rest Setup

### Configuration Example
```yaml
# mongod.conf for Enterprise with Encryption at Rest
security:
  enableEncryption: true
  encryptionCipherMode: AES256-CBC
  encryptionKeyFile: /path/to/keyfile
  kmip:
    serverName: kmip.example.com
    port: 5696
    clientCertificateFile: /path/to/client.pem
    serverCAFile: /path/to/ca.pem
```

### Key Management Options
1. **Local Key Management:** Simple file-based keys
2. **KMIP:** Key Management Interoperability Protocol
3. **Cloud KMS:** AWS KMS, Azure Key Vault, Google Cloud KMS

## Performance Considerations

### Storage-Level Encryption
- Minimal performance impact (typically <5%)
- Encryption/decryption handled by storage engine
- No impact on query performance

### Field-Level Encryption
- Performance impact depends on implementation
- Hashing operations are intentionally slow (security feature)
- Consider async operations for heavy encryption tasks
- Cache decrypted data when appropriate (with security considerations)

## Summary

Encryption at Rest is crucial for protecting sensitive data in MongoDB applications. The two-layered approach provides comprehensive security:

1. **Storage-level encryption** (MongoDB Enterprise) protects against physical threats
2. **Field-level encryption** (application-level) protects against database breaches

Key takeaways:
- Always hash passwords using strong algorithms (bcrypt, Argon2)
- Encrypt sensitive PII and financial data at the field level
- Use MongoDB Enterprise encryption for comprehensive file-level protection
- Implement proper key management and rotation policies
- Regular security audits and compliance checks are essential

Remember: Security is not a one-time implementation but an ongoing process that requires regular updates and monitoring.